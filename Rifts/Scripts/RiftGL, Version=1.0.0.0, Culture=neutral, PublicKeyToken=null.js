/* Generated by JSIL v0.7.9 build 31106. See http://jsil.org/ for more information. */ 
var $asm02 = JSIL.DeclareAssembly("RiftGL, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");

JSIL.DeclareNamespace("RiftGL");
JSIL.DeclareNamespace("RiftGL.Objects");
/* class RiftGL.Objects.AttributeCollection */ 

(function AttributeCollection$Members () {
  var $, $thisType;
  function AttributeCollection__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "RiftGL.Objects.AttributeCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      AttributeCollection__ctor
    );

    $.Field({Static:false, Public:true }, "VertexPosition", $.Object); 
    $.Field({Static:false, Public:true }, "VertexNormal", $.Object); 
    $.Field({Static:false, Public:true }, "TextureCoord", $.Object); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Objects.UniformCollection */ 

(function UniformCollection$Members () {
  var $, $thisType;
  function UniformCollection__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "RiftGL.Objects.UniformCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      UniformCollection__ctor
    );

    $.Field({Static:false, Public:true }, "ProjectionMatrix", $.Object); 
    $.Field({Static:false, Public:true }, "ModelViewMatrix", $.Object); 
    $.Field({Static:false, Public:true }, "NormalMatrix", $.Object); 
    $.Field({Static:false, Public:true }, "Sampler", $.Object); 
    $.Field({Static:false, Public:true }, "UseLighting", $.Object); 
    $.Field({Static:false, Public:true }, "AmbientColor", $.Object); 
    $.Field({Static:false, Public:true }, "LightingDirection", $.Object); 
    $.Field({Static:false, Public:true }, "DirectionalColor", $.Object); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Objects.BufferCollection */ 

(function BufferCollection$Members () {
  var $, $thisType;
  function BufferCollection__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "RiftGL.Objects.BufferCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      BufferCollection__ctor
    );

    $.Field({Static:false, Public:true }, "CubeVertexPositions", $.Object); 
    $.Field({Static:false, Public:true }, "CubeVertexNormals", $.Object); 
    $.Field({Static:false, Public:true }, "CubeTextureCoords", $.Object); 
    $.Field({Static:false, Public:true }, "CubeIndices", $.Object); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Objects.MatrixCollection */ 

(function MatrixCollection$Members () {
  var $, $thisType;
  function MatrixCollection__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "RiftGL.Objects.MatrixCollection", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      MatrixCollection__ctor
    );

    $.Field({Static:false, Public:true }, "Projection", $jsilcore.TypeRef("System.Array", [$.Single])); 
    $.Field({Static:false, Public:true }, "ModelView", $jsilcore.TypeRef("System.Array", [$.Single])); 
    $.Field({Static:false, Public:true }, "Normal", $jsilcore.TypeRef("System.Array", [$.Single])); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Objects.CubeData */ 

(function CubeData$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm01.System.UInt16)) ();
  };

  JSIL.MakeStaticClass("RiftGL.Objects.CubeData", true, [], function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Field({Static:true , Public:true , ReadOnly:true }, "Positions", $jsilcore.TypeRef("System.Array", [$.Single])); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Normals", $jsilcore.TypeRef("System.Array", [$.Single])); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "TexCoords", $jsilcore.TypeRef("System.Array", [$.Single])); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Indices", $jsilcore.TypeRef("System.Array", [$.UInt16])); 
    function CubeData__cctor () {
      $thisType.Positions = JSIL.Array.New($T00(), [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
      $thisType.Normals = JSIL.Array.New($T00(), [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
      $thisType.TexCoords = JSIL.Array.New($T00(), [0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
      $thisType.Indices = JSIL.Array.New($T01(), [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      CubeData__cctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Objects.Inventory */ 

(function Inventory$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.System.Int32)) ();
  };

  function Inventory__ctor$00 () {
    this.Inventory$Previous$value = this;
    this.Inventory$Next$value = this;
  };

  function Inventory__ctor$01 (parent) {
    $thisType.prototype._ctor.call(this);
    this.AttachTo(parent);
  };

  function Inventory_Attach (newChild) {
    if (newChild.get_HasParent()) {
      newChild.Detach();
    }
    newChild.Inventory$Parent$value = this;
    if (this.Inventory$Child$value !== null) {
      newChild.Inventory$Previous$value = this.Inventory$Child$value.Inventory$Previous$value;
      newChild.Inventory$Next$value = this.Inventory$Child$value;
      this.Inventory$Child$value.Inventory$Previous$value.Inventory$Next$value = newChild;
      this.Inventory$Child$value.Inventory$Previous$value = newChild;
    } else {
      this.Inventory$Child$value = newChild;
    }
  };

  function Inventory_AttachTo (newParent) {
    if (this.Inventory$Parent$value !== null) {
      this.Detach();
    }
    this.Inventory$Parent$value = newParent;
    if (this.Inventory$Parent$value.Inventory$Child$value !== null) {
      this.Inventory$Previous$value = this.Inventory$Parent$value.Inventory$Child$value.Inventory$Previous$value;
      this.Inventory$Next$value = this.Inventory$Parent$value.Inventory$Child$value;
      this.Inventory$Parent$value.Inventory$Child$value.Inventory$Previous$value.Inventory$Next$value = this;
      this.Inventory$Parent$value.Inventory$Child$value.Inventory$Previous$value = this;
    } else {
      this.Inventory$Parent$value.Inventory$Child$value = this;
    }
  };

  function Inventory_CountNodes () {
    if (this.Inventory$Child$value !== null) {
      var result = ((((this.Inventory$Child$value).CountNodes() | 0) + 1) | 0);
    } else {
      result = 1;
    }
    return result;
  };

  function Inventory_Detach () {
    if (!((this.Inventory$Parent$value === null) || (this.Inventory$Parent$value.Inventory$Child$value !== this))) {
      if (this.Inventory$Next$value !== this) {
        this.Inventory$Parent$value.Inventory$Child$value = this.Inventory$Next$value;
      } else {
        this.Inventory$Parent$value.Inventory$Child$value = null;
      }
    }
    this.Inventory$Previous$value.Inventory$Next$value = this.Inventory$Next$value;
    this.Inventory$Next$value.Inventory$Previous$value = this.Inventory$Previous$value;
    this.Inventory$Previous$value = this;
    this.Inventory$Next$value = this;
  };

  function Inventory_get_Child () {
    return this.Inventory$Child$value;
  };

  function Inventory_get_HasChild () {
    return (this.Inventory$Child$value !== null);
  };

  function Inventory_get_HasParent () {
    return (this.Inventory$Parent$value !== null);
  };

  function Inventory_get_Next () {
    return this.Inventory$Next$value;
  };

  function Inventory_get_Parent () {
    return this.Inventory$Parent$value;
  };

  function Inventory_get_Previous () {
    return this.Inventory$Previous$value;
  };

  function Inventory_IsFirstChild () {
    return ((this.Inventory$Parent$value !== null) && (this.Inventory$Parent$value.Inventory$Child$value === this));
  };

  function Inventory_IsLastChild () {
    return ((this.Inventory$Parent$value !== null) && (this.Inventory$Parent$value.Inventory$Child$value.Inventory$Previous$value === this));
  };

  function Inventory_set_Child (value) {
    this.Inventory$Child$value = value;
  };

  function Inventory_set_Next (value) {
    this.Inventory$Next$value = value;
  };

  function Inventory_set_Parent (value) {
    this.Inventory$Parent$value = value;
  };

  function Inventory_set_Previous (value) {
    this.Inventory$Previous$value = value;
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "RiftGL.Objects.Inventory", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Inventory__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      Inventory__ctor$01
    );

    $.Method({Static:false, Public:true }, "Attach", 
      JSIL.MethodSignature.Action($.Type), 
      Inventory_Attach
    );

    $.Method({Static:false, Public:true }, "AttachTo", 
      JSIL.MethodSignature.Action($.Type), 
      Inventory_AttachTo
    );

    $.Method({Static:false, Public:true }, "CountNodes", 
      JSIL.MethodSignature.Return($.Int32), 
      Inventory_CountNodes
    );

    $.Method({Static:false, Public:true }, "Detach", 
      JSIL.MethodSignature.Void, 
      Inventory_Detach
    );

    $.Method({Static:false, Public:true }, "get_Child", 
      JSIL.MethodSignature.Return($.Type), 
      Inventory_get_Child
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_HasChild", 
      JSIL.MethodSignature.Return($.Boolean), 
      Inventory_get_HasChild
    );

    $.Method({Static:false, Public:true }, "get_HasParent", 
      JSIL.MethodSignature.Return($.Boolean), 
      Inventory_get_HasParent
    );

    $.Method({Static:false, Public:true }, "get_Next", 
      JSIL.MethodSignature.Return($.Type), 
      Inventory_get_Next
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_Parent", 
      JSIL.MethodSignature.Return($.Type), 
      Inventory_get_Parent
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_Previous", 
      JSIL.MethodSignature.Return($.Type), 
      Inventory_get_Previous
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "IsFirstChild", 
      JSIL.MethodSignature.Return($.Boolean), 
      Inventory_IsFirstChild
    );

    $.Method({Static:false, Public:true }, "IsLastChild", 
      JSIL.MethodSignature.Return($.Boolean), 
      Inventory_IsLastChild
    );

    $.Method({Static:false, Public:true }, "set_Child", 
      JSIL.MethodSignature.Action($.Type), 
      Inventory_set_Child
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_Next", 
      JSIL.MethodSignature.Action($.Type), 
      Inventory_set_Next
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_Parent", 
      JSIL.MethodSignature.Action($.Type), 
      Inventory_set_Parent
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_Previous", 
      JSIL.MethodSignature.Action($.Type), 
      Inventory_set_Previous
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Field({Static:false, Public:false}, "Inventory$Parent$value", $.Type)
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "Inventory$Child$value", $.Type)
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "Inventory$Previous$value", $.Type)
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "Inventory$Next$value", $.Type)
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Property({Static:false, Public:true }, "Parent", $.Type);

    $.Property({Static:false, Public:true }, "Child", $.Type);

    $.Property({Static:false, Public:true }, "Previous", $.Type);

    $.Property({Static:false, Public:true }, "Next", $.Type);

    $.Property({Static:false, Public:true }, "HasParent", $.Boolean);

    $.Property({Static:false, Public:true }, "HasChild", $.Boolean);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Objects.GlObject */ 

(function GlObject$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm03.System.Collections.Generic.Stack$b1.Of($asm01.System.Object))) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm02.RiftGL.Objects.Inventory)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm02.RiftGL.Objects.Vector)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm01.System.Single)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm02.RiftGL.View.ViewPort)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm03.TypeRef("System.Collections.Generic.Stack`1", [$asm01.TypeRef("System.Object")]), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm02.TypeRef("RiftGL.Objects.Vector"), null))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm02.TypeRef("RiftGL.Objects.Vector"), [$asm02.TypeRef("RiftGL.Objects.Vector"), $asm01.TypeRef("System.Single")]))) ();
  };

  function GlObject__ctor$00 () {
    this.glViewMatrix = $S00().Construct();
    $T01().prototype._ctor.call(this);
    this.GlObject$Position$value = $S01().Construct();
    this.GlObject$Velocity$value = $S01().Construct();
    this.GlObject$Acceleration$value = $S01().Construct();
  };

  function GlObject__ctor$01 (parent) {
    this.glViewMatrix = $S00().Construct();
    $T01().prototype._ctor.call(this, parent);
    this.GlObject$Position$value = $S01().Construct();
    this.GlObject$Velocity$value = $S01().Construct();
    this.GlObject$Acceleration$value = $S01().Construct();
  };

  function GlObject_Animate (deltaTime) {
    this.OnAnimate(deltaTime);
    if (this.get_HasChild()) {
      ($thisType.$Cast(this.Inventory$Child$value)).Animate(deltaTime);
    }
    if (!(!this.get_HasParent() || this.IsLastChild())) {
      ($thisType.$Cast(this.Inventory$Next$value)).Animate(deltaTime);
    }
  };

  function GlObject_Draw (camera) {
    this.OnDraw(camera);
  };

  function GlObject_FindRoot () {
    if (this.Inventory$Parent$value !== null) {
      var result = ($thisType.$Cast(this.Inventory$Parent$value)).FindRoot();
    } else {
      result = this;
    }
    return result;
  };

  function GlObject_get_Acceleration () {
    return this.GlObject$Acceleration$value;
  };

  function GlObject_get_Position () {
    return this.GlObject$Position$value;
  };

  function GlObject_get_Size () {
    return this.GlObject$Size$value;
  };

  function GlObject_get_Velocity () {
    return this.GlObject$Velocity$value;
  };

  function GlObject_Load () {
  };

  function GlObject_OnAnimate (deltaTime) {
    this.GlObject$Position$value = $T02().op_Addition(this.GlObject$Position$value, $S02().CallStatic($T02(), "op_Multiply", null, this.GlObject$Velocity$value, deltaTime));
    this.GlObject$Velocity$value = $T02().op_Addition(this.GlObject$Velocity$value, $S02().CallStatic($T02(), "op_Multiply", null, this.GlObject$Acceleration$value, deltaTime));
  };

  function GlObject_OnCollision (collisionObject) {
  };

  function GlObject_OnDraw (camera) {
  };

  function GlObject_OnPrepare () {
    this.ProcessCollisions(this.FindRoot());
  };

  function GlObject_Prepare () {
    this.OnPrepare();
    if (this.get_HasChild()) {
      ($thisType.$Cast(this.Inventory$Child$value)).Prepare();
    }
    if (!(!this.get_HasParent() || this.IsLastChild())) {
      ($thisType.$Cast(this.Inventory$Next$value)).Prepare();
    }
  };

  function GlObject_ProcessCollisions (obj) {
    if (+($T02().op_Subtraction(obj.GlObject$Position$value, this.GlObject$Position$value)).Length() <= (+obj.GlObject$Size$value + +this.GlObject$Size$value)) {
      this.OnCollision(obj);
      if (this.get_HasChild()) {
        ($thisType.$Cast(this.Inventory$Child$value)).ProcessCollisions(obj);
      }
      if (!(!this.get_HasParent() || this.IsLastChild())) {
        ($thisType.$Cast(this.Inventory$Next$value)).ProcessCollisions(obj);
      }
    }
    if (obj.get_HasChild()) {
      this.ProcessCollisions($thisType.$Cast(obj.Inventory$Child$value));
    }
    if (!(!obj.get_HasParent() || obj.IsLastChild())) {
      this.ProcessCollisions($thisType.$Cast(obj.Inventory$Next$value));
    }
  };

  function GlObject_set_Acceleration (value) {
    this.GlObject$Acceleration$value = value;
  };

  function GlObject_set_Position (value) {
    this.GlObject$Position$value = value;
  };

  function GlObject_set_Size (value) {
    this.GlObject$Size$value = +value;
  };

  function GlObject_set_Velocity (value) {
    this.GlObject$Velocity$value = value;
  };

  function GlObject_Unload () {
  };

  JSIL.MakeType({
      BaseType: $asm02.TypeRef("RiftGL.Objects.Inventory"), 
      Name: "RiftGL.Objects.GlObject", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 1, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Void, 
      GlObject__ctor$00
    );

    $.Method({Static:false, Public:false}, ".ctor", 
      JSIL.MethodSignature.Action($asm02.TypeRef("RiftGL.Objects.Inventory")), 
      GlObject__ctor$01
    );

    $.Method({Static:false, Public:true }, "Animate", 
      JSIL.MethodSignature.Action($.Single), 
      GlObject_Animate
    );

    $.Method({Static:false, Public:true }, "Draw", 
      JSIL.MethodSignature.Action($asm02.TypeRef("RiftGL.View.ViewPort")), 
      GlObject_Draw
    );

    $.Method({Static:false, Public:false}, "FindRoot", 
      JSIL.MethodSignature.Return($.Type), 
      GlObject_FindRoot
    );

    $.Method({Static:false, Public:true }, "get_Acceleration", 
      JSIL.MethodSignature.Return($asm02.TypeRef("RiftGL.Objects.Vector")), 
      GlObject_get_Acceleration
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_Position", 
      JSIL.MethodSignature.Return($asm02.TypeRef("RiftGL.Objects.Vector")), 
      GlObject_get_Position
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_Size", 
      JSIL.MethodSignature.Return($.Single), 
      GlObject_get_Size
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_Velocity", 
      JSIL.MethodSignature.Return($asm02.TypeRef("RiftGL.Objects.Vector")), 
      GlObject_get_Velocity
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "Load", 
      JSIL.MethodSignature.Void, 
      GlObject_Load
    );

    $.Method({Static:false, Public:false, Virtual:true }, "OnAnimate", 
      JSIL.MethodSignature.Action($.Single), 
      GlObject_OnAnimate
    );

    $.Method({Static:false, Public:false, Virtual:true }, "OnCollision", 
      JSIL.MethodSignature.Action($.Type), 
      GlObject_OnCollision
    );

    $.Method({Static:false, Public:false, Virtual:true }, "OnDraw", 
      JSIL.MethodSignature.Action($asm02.TypeRef("RiftGL.View.ViewPort")), 
      GlObject_OnDraw
    );

    $.Method({Static:false, Public:false, Virtual:true }, "OnPrepare", 
      JSIL.MethodSignature.Void, 
      GlObject_OnPrepare
    );

    $.Method({Static:false, Public:true }, "Prepare", 
      JSIL.MethodSignature.Void, 
      GlObject_Prepare
    );

    $.Method({Static:false, Public:true }, "ProcessCollisions", 
      JSIL.MethodSignature.Action($.Type), 
      GlObject_ProcessCollisions
    );

    $.Method({Static:false, Public:true }, "set_Acceleration", 
      JSIL.MethodSignature.Action($asm02.TypeRef("RiftGL.Objects.Vector")), 
      GlObject_set_Acceleration
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_Position", 
      JSIL.MethodSignature.Action($asm02.TypeRef("RiftGL.Objects.Vector")), 
      GlObject_set_Position
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_Size", 
      JSIL.MethodSignature.Action($.Single), 
      GlObject_set_Size
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_Velocity", 
      JSIL.MethodSignature.Action($asm02.TypeRef("RiftGL.Objects.Vector")), 
      GlObject_set_Velocity
    )
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:false, Virtual:true }, "Unload", 
      JSIL.MethodSignature.Void, 
      GlObject_Unload
    );

    $.Field({Static:false, Public:false}, "glViewMatrix", $asm03.TypeRef("System.Collections.Generic.Stack`1", [$.Object])); 
    $.Field({Static:false, Public:false}, "GlObject$Acceleration$value", $asm02.TypeRef("RiftGL.Objects.Vector"))
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "GlObject$Position$value", $asm02.TypeRef("RiftGL.Objects.Vector"))
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "GlObject$Velocity$value", $asm02.TypeRef("RiftGL.Objects.Vector"))
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Field({Static:false, Public:false}, "GlObject$Size$value", $.Single)
      .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    $.Property({Static:false, Public:true }, "Acceleration", $asm02.TypeRef("RiftGL.Objects.Vector"));

    $.Property({Static:false, Public:true }, "Position", $asm02.TypeRef("RiftGL.Objects.Vector"));

    $.Property({Static:false, Public:true }, "Velocity", $asm02.TypeRef("RiftGL.Objects.Vector"));

    $.Property({Static:false, Public:true }, "Size", $.Single);

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Objects.Crate */ 

(function Crate$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm02.RiftGL.Objects.GlObject)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm02.RiftGL.Objects.Vector)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm02.RiftGL.View.ViewPort)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm01.System.String)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm01.System.IO.Path)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm01.System.Object)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm01.System.IO.File)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm01.System.Boolean)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm01.System.Console)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm01.System.NotImplementedException)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm01.System.Single)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm01.System.Exception)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm02.RiftGL.Objects.Crate_$l$gc__DisplayClass2a)) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm01.System.Action)) ();
  };
  var $T0E = function () {
    return ($T0E = JSIL.Memoize(System.Array.Of($asm01.System.Byte))) ();
  };
  var $T0F = function () {
    return ($T0F = JSIL.Memoize(System.Array.Of($asm01.System.Single))) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm02.TypeRef("RiftGL.Objects.Vector"), null))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm01.TypeRef("System.NotImplementedException"), [$asm01.TypeRef("System.String")]))) ();
  };

  function Crate__ctor () {
    $T00().prototype._ctor.call(this);
    this.Rotation = $S00().Construct();
  };

  function Crate_CompileShader (viewPort, filename) {

    var $label0 = 0;
  $labelgroup0: 
    while (true) {
      switch ($label0) {
        case 0: /* $entry0 */ 
          var extension = ($T04().GetExtension(filename).toLowerCase());
          var text = extension;
          if (text !== null) {
            if (!(text == "fs")) {
              if (!(text == "vs")) {
                $label0 = 1 /* goto IL_1B8 */ ;
                continue $labelgroup0;
              }
              var arg_1B0_2 = viewPort.GL;
              var shaderObject = arg_1B0_2.createShader(viewPort.GL.VERTEX_SHADER);
            } else {
              var arg_F0_2 = viewPort.GL;
              shaderObject = arg_F0_2.createShader(viewPort.GL.FRAGMENT_SHADER);
            }
            var shaderText = $T06().ReadAllText(filename);
            (viewPort.GL).shaderSource(shaderObject, shaderText);
            (viewPort.GL).compileShader(shaderObject);
            var arg_3A1_2 = viewPort.GL;
            var arg_3A1_3 = shaderObject;
            if (!$T07().$Cast(arg_3A1_2.getShaderParameter(arg_3A1_3, viewPort.GL.COMPILE_STATUS))) {
              var arg_480_2 = JSIL.GlobalNamespace.alert;
              arg_480_2((viewPort.GL).getShaderInfoLog(shaderObject));
              var result = null;
            } else {
              $T08().WriteLine(JSIL.ConcatString("Loaded ", filename));
              result = shaderObject;
            }
            return result;
          }

          $label0 = 1 /* goto IL_1B8 */ ;
          continue $labelgroup0;
        case 1: /* IL_1B8 */ 
          throw $S01().Construct(extension);

          break $labelgroup0;
      }
    }
  };

  function Crate_DegreesToRadians (degrees) {
    return Math.fround(+((+degrees * 3.1415926535897931) / 180));
  };

  function Crate_InitShaders (viewPort) {
    var fragmentShader = $thisType.CompileShader(viewPort, "crate.fs");
    var vertexShader = $thisType.CompileShader(viewPort, "crate.vs");
    $thisType.ShaderProgram = (viewPort.GL).createProgram();
    (viewPort.GL).attachShader($thisType.ShaderProgram, vertexShader);
    (viewPort.GL).attachShader($thisType.ShaderProgram, fragmentShader);
    (viewPort.GL).linkProgram($thisType.ShaderProgram);
    var arg_2BD_2 = viewPort.GL;
    if (!$T07().$Cast(arg_2BD_2.getProgramParameter($thisType.ShaderProgram, viewPort.GL.LINK_STATUS))) {
      JSIL.GlobalNamespace.alert("Could not link shader");
    } else {
      (viewPort.GL).useProgram($thisType.ShaderProgram);
      $T02().Attributes.VertexPosition = (viewPort.GL).getAttribLocation($thisType.ShaderProgram, "aVertexPosition");
      $T02().Attributes.VertexNormal = (viewPort.GL).getAttribLocation($thisType.ShaderProgram, "aVertexNormal");
      $T02().Attributes.TextureCoord = (viewPort.GL).getAttribLocation($thisType.ShaderProgram, "aTextureCoord");
      $T02().Uniforms.ProjectionMatrix = (viewPort.GL).getUniformLocation($thisType.ShaderProgram, "uPMatrix");
      $T02().Uniforms.ModelViewMatrix = (viewPort.GL).getUniformLocation($thisType.ShaderProgram, "uMVMatrix");
      $T02().Uniforms.NormalMatrix = (viewPort.GL).getUniformLocation($thisType.ShaderProgram, "uNMatrix");
      $T02().Uniforms.Sampler = (viewPort.GL).getUniformLocation($thisType.ShaderProgram, "uSampler");
      $T02().Uniforms.UseLighting = (viewPort.GL).getUniformLocation($thisType.ShaderProgram, "uUseLighting");
      $T02().Uniforms.AmbientColor = (viewPort.GL).getUniformLocation($thisType.ShaderProgram, "uAmbientColor");
      $T02().Uniforms.LightingDirection = (viewPort.GL).getUniformLocation($thisType.ShaderProgram, "uLightingDirection");
      $T02().Uniforms.DirectionalColor = (viewPort.GL).getUniformLocation($thisType.ShaderProgram, "uDirectionalColor");
    }
  };

  function Crate_InitTexture (viewPort, document, $exception) {
    var $closure0 = new ($T0C())();
    $closure0.viewPort = viewPort;
    $thisType.CrateTexture = ($closure0.viewPort.GL).createTexture();
    var arg_CD_0 = $closure0;
    arg_CD_0.imageElement = document.createElement("img");
    $closure0.imageElement.onload = $T0D().New($closure0, $T0C().prototype.$lInitTexture$gb__29);
    try {
      var imageBytes = $T06().ReadAllBytes("crate.png");
      var objectUrl = JSIL.GlobalNamespace.JSIL.GetObjectURLForBytes(imageBytes, "image/png");
      $closure0.imageElement.src = objectUrl;
    } catch ($exception) {
      $T08().WriteLine("Falling back to a second HTTP request for crate.png because Object URLs are not available");
      $closure0.imageElement.src = "Files/crate.png";
    }
  };

  function Crate_OnAnimate (deltaTime) {
    $T00().prototype.OnAnimate.call(this, deltaTime);
    this.Rotation.X += +(((+this.Speed.X * +deltaTime) / 1000));
    this.Rotation.Y += +(((+this.Speed.Y * +deltaTime) / 1000));
  };

  function Crate_OnDraw (camera) {
    $T02().GLMatrix4.identity($T02().Matrices.ModelView);
    $T02().GLMatrix4.translate($T02().Matrices.ModelView, JSIL.Array.New($T0A(), [0, 0, this.GlObject$Position$value.Z]));
    var array = JSIL.Array.New($T0A(), 3);
    array[0] = 1;
    $T02().GLMatrix4.rotate($T02().Matrices.ModelView, $thisType.DegreesToRadians(this.Rotation.X), array);
    array = JSIL.Array.New($T0A(), 3);
    array[1] = 1;
    $T02().GLMatrix4.rotate($T02().Matrices.ModelView, $thisType.DegreesToRadians(this.Rotation.Y), array);
    var arg_303_2 = camera.GL;
    arg_303_2.bindBuffer(camera.GL.ARRAY_BUFFER, $T02().Buffers.CubeVertexPositions);
    var arg_3FB_2 = camera.GL;
    arg_3FB_2.vertexAttribPointer(
      $T02().Attributes.VertexPosition, 
      3, 
      camera.GL.FLOAT, 
      false, 
      0, 
      0
    );
    var arg_4C7_2 = camera.GL;
    arg_4C7_2.bindBuffer(camera.GL.ARRAY_BUFFER, $T02().Buffers.CubeVertexNormals);
    var arg_5BF_2 = camera.GL;
    arg_5BF_2.vertexAttribPointer(
      $T02().Attributes.VertexNormal, 
      3, 
      camera.GL.FLOAT, 
      false, 
      0, 
      0
    );
    var arg_68B_2 = camera.GL;
    arg_68B_2.bindBuffer(camera.GL.ARRAY_BUFFER, $T02().Buffers.CubeTextureCoords);
    var arg_783_2 = camera.GL;
    arg_783_2.vertexAttribPointer(
      $T02().Attributes.TextureCoord, 
      2, 
      camera.GL.FLOAT, 
      false, 
      0, 
      0
    );
    var arg_83B_2 = camera.GL;
    arg_83B_2.activeTexture(camera.GL.TEXTURE0);
    var arg_902_2 = camera.GL;
    arg_902_2.bindTexture(camera.GL.TEXTURE_2D, $thisType.CrateTexture);
    (camera.GL).uniform1i($T02().Uniforms.Sampler, 0);
  };

  JSIL.MakeType({
      BaseType: $asm02.TypeRef("RiftGL.Objects.GlObject"), 
      Name: "RiftGL.Objects.Crate", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Crate__ctor
    );

    $.Method({Static:true , Public:true }, "CompileShader", 
      new JSIL.MethodSignature($.Object, [$asm02.TypeRef("RiftGL.View.ViewPort"), $.String]), 
      Crate_CompileShader
    );

    $.Method({Static:true , Public:true }, "DegreesToRadians", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      Crate_DegreesToRadians
    );

    $.Method({Static:false, Public:true }, "InitShaders", 
      JSIL.MethodSignature.Action($asm02.TypeRef("RiftGL.View.ViewPort")), 
      Crate_InitShaders
    );

    $.Method({Static:false, Public:true }, "InitTexture", 
      new JSIL.MethodSignature(null, [$asm02.TypeRef("RiftGL.View.ViewPort"), $.Object]), 
      Crate_InitTexture
    )
      .Parameter(1, "document", function (_) {
          _.Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute"))
        });

    $.Method({Static:false, Public:false, Virtual:true }, "OnAnimate", 
      JSIL.MethodSignature.Action($.Single), 
      Crate_OnAnimate
    );

    $.Method({Static:false, Public:false, Virtual:true }, "OnDraw", 
      JSIL.MethodSignature.Action($asm02.TypeRef("RiftGL.View.ViewPort")), 
      Crate_OnDraw
    );

    $.Field({Static:true , Public:true }, "ShaderProgram", $.Object); 
    $.Field({Static:true , Public:true }, "CrateTexture", $.Object); 
    $.Field({Static:false, Public:true }, "Rotation", $asm02.TypeRef("RiftGL.Objects.Vector")); 
    $.Field({Static:false, Public:true }, "Speed", $asm02.TypeRef("RiftGL.Objects.Vector")); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Objects.Crate+<>c__DisplayClass2a */ 

(function $l$gc__DisplayClass2a$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm02.RiftGL.Objects.Crate)) ();
  };

  function $l$gc__DisplayClass2a__ctor () {
  };

  function $l$gc__DisplayClass2a_$lInitTexture$gb__29 () {
    (this.viewPort).UploadTexture($T00().CrateTexture, this.imageElement);
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "RiftGL.Objects.Crate+<>c__DisplayClass2a", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      $l$gc__DisplayClass2a__ctor
    );

    $.Method({Static:false, Public:true }, "$lInitTexture$gb__29", 
      JSIL.MethodSignature.Void, 
      $l$gc__DisplayClass2a_$lInitTexture$gb__29
    );

    $.Field({Static:false, Public:true }, "imageElement", $.Object); 
    $.Field({Static:false, Public:true }, "viewPort", $asm02.TypeRef("RiftGL.View.ViewPort")); 
    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm01.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

})();

/* class RiftGL.Objects.Vector */ 

(function Vector$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm01.System.Math)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm01.System.Double)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm02.TypeRef("RiftGL.Objects.Vector"), [
        $asm01.TypeRef("System.Single"), $asm01.TypeRef("System.Single"), 
        $asm01.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm02.TypeRef("RiftGL.Objects.Vector"), [$asm02.TypeRef("RiftGL.Objects.Vector")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm02.TypeRef("RiftGL.Objects.Vector"), [$asm02.TypeRef("RiftGL.Objects.Vector"), $asm01.TypeRef("System.Single")]))) ();
  };

  function Vector__ctor$00 () {
  };

  function Vector__ctor$01 (x, y, z) {
    this.X = +x;
    this.Y = +y;
    this.Z = +z;
  };

  function Vector__ctor$02 (vector) {
    this.X = +vector.X;
    this.Y = +vector.Y;
    this.Z = +vector.Z;
  };

  function Vector_Angle (normal) {
    return Math.fround(Math.acos($thisType.op_Modulus(this, normal)));
  };

  function Vector_CrossProduct (vector) {
    return $S00().Construct(((+this.Y * +vector.Z) - (+this.Z * +vector.Y)), ((+this.Z * +vector.X) - (+this.X * +vector.Z)), ((+this.X * +vector.Y) - (+this.Y * +vector.X)));
  };

  function Vector_DotProduct (vector) {
    return (((+this.X * +vector.X) + (+this.Y * +vector.Y)) + (+this.Z * +vector.Z));
  };

  function Vector_Length () {
    return Math.fround(Math.sqrt((((+this.X * +this.X) + (+this.Y * +this.Y)) + (+this.Z * +this.Z))));
  };

  function Vector_Normalize () {
    var result = $thisType.op_Division(this, this.Length());
    this.X = +result.X;
    this.Y = +result.Y;
    this.Z = +result.Z;
  };

  function Vector_op_Addition (x, y) {
    return $S00().Construct((+x.X + +y.X), (+x.Y + +y.Y), (+x.Z + +y.Z));
  };

  function Vector_op_BitwiseOr (x, length) {
    var result = $S01().Construct(x);
    return $S02().CallStatic($thisType, "op_Multiply", null, result, +((+length / +x.Length())));
  };

  function Vector_op_Division (x, y) {
    var reciprical = +((1 / +y));
    var result = $S01().Construct(x);
    result.X *= reciprical;
    result.Y *= reciprical;
    result.Z *= reciprical;
    return result;
  };

  function Vector_op_Equality (x, y) {
    return (!(!$thisType.op_Inequality(x, null) || 
        !$thisType.op_Inequality(y, null) || 
        ((Math.abs((+x.X - +y.X))) >= 0.001) || 
        ((Math.abs((+x.Y - +y.Y))) >= 0.001)) && ((Math.abs((+x.Z - +y.Z))) < 0.001));
  };

  function Vector_op_ExclusiveOr (x, y) {
    return $S00().Construct(((+x.Y * +y.Z) - (+x.Z * +y.Y)), ((+x.Z * +y.X) - (+x.X * +y.Z)), ((+x.X * +y.Y) - (+x.Y * +y.X)));
  };

  function Vector_op_Inequality (x, y) {
    return !$thisType.op_Equality(x, y);
  };

  function Vector_op_LogicalNot (x) {
    return x.Length();
  };

  function Vector_op_Modulus (x, y) {
    return (((+x.X * +y.X) + (+x.Y * +y.Y)) + (+x.Z * +y.Z));
  };

  function Vector_op_Multiply$03 (x, y) {
    var result = $S01().Construct(x);
    result.X *= +y.X;
    result.Y *= +y.Y;
    result.Z *= +y.Z;
    return result;
  };

  function Vector_op_Multiply$04 (x, y) {
    var result = $S01().Construct(x);
    result.X *= +y;
    result.Y *= +y;
    result.Z *= +y;
    return result;
  };

  function Vector_op_Subtraction (x, y) {
    return $S00().Construct((+x.X - +y.X), (+x.Y - +y.Y), (+x.Z - +y.Z));
  };

  function Vector_Reflection (normal) {
    var unitVector = $thisType.op_BitwiseOr(this, 1);
    return $S02().CallStatic($thisType, "op_Multiply", null, 
      $thisType.op_Subtraction(unitVector, $S02().CallStatic($thisType, "op_Multiply", null, 
          $S02().CallStatic($thisType, "op_Multiply", null, normal, 2), 
          $thisType.op_Modulus(unitVector, normal)
        )), 
      this.Length()
    );
  };

  function Vector_UnitVector () {
    return $thisType.op_Division(this, this.Length());
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "RiftGL.Objects.Vector", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      Vector__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single
        ]), 
      Vector__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      Vector__ctor$02
    );

    $.Method({Static:false, Public:true }, "Angle", 
      new JSIL.MethodSignature($.Single, [$.Type]), 
      Vector_Angle
    );

    $.Method({Static:false, Public:true }, "CrossProduct", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Vector_CrossProduct
    );

    $.Method({Static:false, Public:true }, "DotProduct", 
      new JSIL.MethodSignature($.Single, [$.Type]), 
      Vector_DotProduct
    );

    $.Method({Static:false, Public:true }, "Length", 
      JSIL.MethodSignature.Return($.Single), 
      Vector_Length
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      Vector_Normalize
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Vector_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_BitwiseOr", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      Vector_op_BitwiseOr
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      Vector_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      Vector_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_ExclusiveOr", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Vector_op_ExclusiveOr
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      Vector_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_LogicalNot", 
      new JSIL.MethodSignature($.Single, [$.Type]), 
      Vector_op_LogicalNot
    );

    $.Method({Static:true , Public:true }, "op_Modulus", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      Vector_op_Modulus
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Vector_op_Multiply$03
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      Vector_op_Multiply$04
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Vector_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "Reflection", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Vector_Reflection
    );

    $.Method({Static:false, Public:true }, "UnitVector", 
      JSIL.MethodSignature.Return($.Type), 
      Vector_UnitVector
    );

    $.Field({Static:false, Public:true }, "X", $.Single); 
    $.Field({Static:false, Public:true }, "Y", $.Single); 
    $.Field({Static:false, Public:true }, "Z", $.Single); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class RiftGL.Page */ 

(function Page$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm01.System.Boolean)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm01.System.Int32)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm01.System.Environment)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm02.RiftGL.Objects.GlObject)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm01.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm02.RiftGL.View.ViewPort)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize(System.Array.Of($asm01.System.UInt16))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm02.RiftGL.Objects.CubeData)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm01.System.Exception)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm01.System.Console)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm02.RiftGL.Objects.Crate)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm02.RiftGL.Objects.Vector)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm01.System.Action$b1.Of($asm01.System.Object))) ();
  };
  var $T0D = function () {
    return ($T0D = JSIL.Memoize($asm01.System.Action)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm02.TypeRef("RiftGL.Objects.Vector"), [
        $asm01.TypeRef("System.Single"), $asm01.TypeRef("System.Single"), 
        $asm01.TypeRef("System.Single")
      ]))) ();
  };

  function Page_Animate () {
    var now = ($T02().get_TickCount() | 0);
    if (($thisType.LastTime | 0) !== 0) {
      var elapsed = ((now - ($thisType.LastTime | 0)) | 0);
      if (elapsed > 0) {
        $thisType.Crate.Animate(+elapsed);
      }
    }
    $thisType.LastTime = now;
  };

  function Page_DrawScene () {
    $thisType.GL.viewport(0, 0, $thisType.Canvas.width, $thisType.Canvas.height);
    var arg_27D_2 = $thisType.GL.COLOR_BUFFER_BIT;
    $thisType.GL.clear(arg_27D_2 | $thisType.GL.DEPTH_BUFFER_BIT);
    var lighting = $T00().$Cast($thisType.Document.getElementById("lighting").checked);
    $thisType.GL.uniform1i($T05().Uniforms.UseLighting, (
        lighting
           ? 1
           : 0)
    );
    if (lighting) {
      $thisType.ViewPort.DrawLighting($thisType.Document);
    }
    $thisType.Crate.Draw($thisType.ViewPort);
    $thisType.GL.bindBuffer($thisType.GL.ELEMENT_ARRAY_BUFFER, $T05().Buffers.CubeIndices);
    $thisType.GL.uniformMatrix4fv($T05().Uniforms.ProjectionMatrix, false, $T05().Matrices.Projection);
    $thisType.GL.uniformMatrix4fv($T05().Uniforms.ModelViewMatrix, false, $T05().Matrices.ModelView);
    $T05().GLMatrix4.toInverseMat3($T05().Matrices.ModelView, $T05().Matrices.Normal);
    $T05().GLMatrix3.transpose($T05().Matrices.Normal);
    $thisType.GL.uniformMatrix3fv($T05().Uniforms.NormalMatrix, false, $T05().Matrices.Normal);
    var arg_901_3 = $thisType.GL.TRIANGLES;
    var arg_901_4 = ($T07().Indices.length | 0);
    $thisType.GL.drawElements(arg_901_3, arg_901_4, $thisType.GL.UNSIGNED_SHORT, 0);
  };

  function Page_HandleKeys () {
    if ($thisType.HeldKeys[33]) {
      $thisType.Crate.GlObject$Position$value.Z -= 0.05;
    }
    if ($thisType.HeldKeys[34]) {
      $thisType.Crate.GlObject$Position$value.Z += 0.05;
    }
    if ($thisType.HeldKeys[37]) {
      $thisType.Crate.Speed.Y -= 1;
    }
    if ($thisType.HeldKeys[39]) {
      $thisType.Crate.Speed.Y += 1;
    }
    if ($thisType.HeldKeys[38]) {
      $thisType.Crate.Speed.X -= 1;
    }
    if ($thisType.HeldKeys[40]) {
      $thisType.Crate.Speed.X += 1;
    }
  };

  function Page_InitBuffers () {
    var arg_11C_3 = $thisType.GL.ARRAY_BUFFER;
    $thisType.GL.bindBuffer(arg_11C_3, $T05().Buffers.CubeVertexPositions = $thisType.GL.createBuffer());
    var arg_23E_3 = $thisType.GL.ARRAY_BUFFER;
    $thisType.GL.bufferData(arg_23E_3, $T07().Positions, $thisType.GL.STATIC_DRAW);
    var arg_35F_3 = $thisType.GL.ARRAY_BUFFER;
    $thisType.GL.bindBuffer(arg_35F_3, $T05().Buffers.CubeVertexNormals = $thisType.GL.createBuffer());
    var arg_481_3 = $thisType.GL.ARRAY_BUFFER;
    $thisType.GL.bufferData(arg_481_3, $T07().Normals, $thisType.GL.STATIC_DRAW);
    var arg_5A2_3 = $thisType.GL.ARRAY_BUFFER;
    $thisType.GL.bindBuffer(arg_5A2_3, $T05().Buffers.CubeTextureCoords = $thisType.GL.createBuffer());
    var arg_6C4_3 = $thisType.GL.ARRAY_BUFFER;
    $thisType.GL.bufferData(arg_6C4_3, $T07().TexCoords, $thisType.GL.STATIC_DRAW);
    var arg_7E5_3 = $thisType.GL.ELEMENT_ARRAY_BUFFER;
    $thisType.GL.bindBuffer(arg_7E5_3, $T05().Buffers.CubeIndices = $thisType.GL.createBuffer());
    var arg_907_3 = $thisType.GL.ELEMENT_ARRAY_BUFFER;
    $thisType.GL.bufferData(arg_907_3, $T07().Indices, $thisType.GL.STATIC_DRAW);
  };

  function Page_InitGL ($exception) {
    var gl = null;
    try {
      gl = $thisType.Canvas.getContext("experimental-webgl");
    } catch ($exception) {
    }
    if (gl) {
      $thisType.GL = gl;
      $T09().WriteLine("Initialized WebGL");
      var result = true;
    } else {
      JSIL.GlobalNamespace.alert("Could not initialize WebGL");
      result = false;
    }
    return result;
  };

  function Page_InitMatrices () {
    $thisType.ViewPort.InitMatrices($thisType.Canvas);
  };

  function Page_InitShaders () {
    $thisType.Crate.InitShaders($thisType.ViewPort);
    $thisType.GL.enableVertexAttribArray($T05().Attributes.VertexPosition);
    $thisType.GL.enableVertexAttribArray($T05().Attributes.VertexNormal);
    $thisType.GL.enableVertexAttribArray($T05().Attributes.TextureCoord);
  };

  function Page_InitTexture () {
    $thisType.Crate.InitTexture($thisType.ViewPort, $thisType.Document);
  };

  function Page_Load () {
    $thisType.Document = JSIL.GlobalNamespace.document;
    $thisType.Canvas = $thisType.Document.getElementById("canvas");
    if ($thisType.InitGL()) {
      $thisType.ViewPort = (new ($T05())()).__Initialize__({
          GL: $thisType.GL}
      );
      $thisType.Crate = (new ($T0A())()).__Initialize__({
          Speed: $S00().Construct(3, -3, 0), 
          Position: $S00().Construct(0, 0, -5)}
      );
      $thisType.InitMatrices();
      $thisType.InitShaders();
      $thisType.InitBuffers();
      $thisType.InitTexture();
      $thisType.GL.clearColor(0, 0, 0, 1);
      $thisType.GL.enable($thisType.GL.DEPTH_TEST);
      $thisType.Document.onkeydown = $T0C().New($thisType, $thisType.OnKeyDown);
      $thisType.Document.onkeyup = $T0C().New($thisType, $thisType.OnKeyUp);
      $thisType.Tick();
    }
  };

  function Page_OnKeyDown (e) {
    $thisType.HeldKeys[$T01().$Cast(e.keyCode)] = 1;
  };

  function Page_OnKeyUp (e) {
    $thisType.HeldKeys[$T01().$Cast(e.keyCode)] = 0;
  };

  function Page_Tick ($exception) {
    JSIL.GlobalNamespace.requestAnimFrame($T0D().New($thisType, $thisType.Tick));
    $thisType.HandleKeys();
    try {
      $thisType.DrawScene();
    } catch ($exception) {
    }
    $thisType.Animate();
  };

  JSIL.MakeStaticClass("RiftGL.Page", true, [], function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:true , Public:true }, "Animate", 
      JSIL.MethodSignature.Void, 
      Page_Animate
    );

    $.Method({Static:true , Public:true }, "DrawScene", 
      JSIL.MethodSignature.Void, 
      Page_DrawScene
    );

    $.Method({Static:true , Public:true }, "HandleKeys", 
      JSIL.MethodSignature.Void, 
      Page_HandleKeys
    );

    $.Method({Static:true , Public:true }, "InitBuffers", 
      JSIL.MethodSignature.Void, 
      Page_InitBuffers
    );

    $.Method({Static:true , Public:true }, "InitGL", 
      JSIL.MethodSignature.Return($.Boolean), 
      Page_InitGL
    );

    $.Method({Static:true , Public:true }, "InitMatrices", 
      JSIL.MethodSignature.Void, 
      Page_InitMatrices
    );

    $.Method({Static:true , Public:true }, "InitShaders", 
      JSIL.MethodSignature.Void, 
      Page_InitShaders
    );

    $.Method({Static:true , Public:true }, "InitTexture", 
      JSIL.MethodSignature.Void, 
      Page_InitTexture
    );

    $.Method({Static:true , Public:true }, "Load", 
      JSIL.MethodSignature.Void, 
      Page_Load
    );

    $.Method({Static:true , Public:true }, "OnKeyDown", 
      JSIL.MethodSignature.Action($.Object), 
      Page_OnKeyDown
    )
      .Parameter(0, "e", function (_) {
          _.Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute"))
        });

    $.Method({Static:true , Public:true }, "OnKeyUp", 
      JSIL.MethodSignature.Action($.Object), 
      Page_OnKeyUp
    )
      .Parameter(0, "e", function (_) {
          _.Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute"))
        });

    $.Method({Static:true , Public:true }, "Tick", 
      JSIL.MethodSignature.Void, 
      Page_Tick
    );

    $.Field({Static:true , Public:true }, "GL", $.Object)
      .Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute")); 
    $.Field({Static:true , Public:true }, "Document", $.Object)
      .Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute")); 
    $.Field({Static:true , Public:true }, "Canvas", $.Object)
      .Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute")); 
    $.Field({Static:true , Public:true }, "HeldKeys", $jsilcore.TypeRef("System.Array", [$.Boolean]), function ($pi) {
        return JSIL.Array.New($asm01.System.Boolean, 255);
      }); 
    $.Field({Static:true , Public:true }, "LastTime", $.Int32, 0); 
    $.Field({Static:true , Public:true }, "ViewPort", $asm02.TypeRef("RiftGL.View.ViewPort")); 
    $.Field({Static:true , Public:true }, "Crate", $asm02.TypeRef("RiftGL.Objects.Crate")); 
    function Page__cctor () {
      $thisType.HeldKeys = JSIL.Array.New($T00(), 255);
      $thisType.LastTime = 0;
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Page__cctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

JSIL.DeclareNamespace("RiftGL.View");
/* class RiftGL.View.ViewPort */ 

(function ViewPort$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm02.RiftGL.Objects.AttributeCollection)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm02.RiftGL.Objects.UniformCollection)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm02.RiftGL.Objects.BufferCollection)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm02.RiftGL.Objects.MatrixCollection)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm01.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm01.System.Single)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize(System.Array.Of($asm01.System.Object))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm01.System.Single))) ();
  };

  function ViewPort__ctor () {
    $thisType.GLVector3 = JSIL.GlobalNamespace.vec3;
    $thisType.GLMatrix4 = JSIL.GlobalNamespace.mat4;
    $thisType.GLMatrix3 = JSIL.GlobalNamespace.mat3;
  };

  function ViewPort_DrawLighting (Document) {
    var arg_3BA_4 = $T05().Parse(Document.getElementById("ambientR").value);
    var arg_3BA_5 = $T05().Parse(Document.getElementById("ambientG").value);
    (this.GL).uniform3f($thisType.Uniforms.AmbientColor, arg_3BA_4, arg_3BA_5, $T05().Parse(Document.getElementById("ambientB").value));
    var array = JSIL.Array.New($T04(), 3);
    var arg_4DA_0 = array;
    arg_4DA_0[0] = $T05().Parse(Document.getElementById("lightDirectionX").value);
    var arg_5EE_0 = array;
    arg_5EE_0[1] = $T05().Parse(Document.getElementById("lightDirectionY").value);
    var arg_702_0 = array;
    arg_702_0[2] = $T05().Parse(Document.getElementById("lightDirectionZ").value);
    var lightingDirection = array;
    $thisType.GLVector3.normalize(lightingDirection, lightingDirection);
    $thisType.GLVector3.scale(lightingDirection, -1);
    (this.GL).uniform3fv($thisType.Uniforms.LightingDirection, lightingDirection);
    var arg_C15_4 = $T05().Parse(Document.getElementById("directionalR").value);
    var arg_C15_5 = $T05().Parse(Document.getElementById("directionalG").value);
    (this.GL).uniform3f($thisType.Uniforms.DirectionalColor, arg_C15_4, arg_C15_5, $T05().Parse(Document.getElementById("directionalB").value));
  };

  function ViewPort_InitMatrices (canvas) {
    $thisType.Matrices.ModelView = $T07().$Cast($thisType.GLMatrix4.create());
    $thisType.Matrices.Projection = $T07().$Cast($thisType.GLMatrix4.create());
    $thisType.Matrices.Normal = $T07().$Cast($thisType.GLMatrix3.create());
    var arg_353_2 = canvas.width;
    $thisType.GLMatrix4.perspective(
      45, 
      arg_353_2 / canvas.height, 
      0.1, 
      100, 
      $thisType.Matrices.Projection
    );
  };

  function ViewPort_UploadTexture (textureHandle, imageElement) {
    (this.GL).pixelStorei(this.GL.UNPACK_FLIP_Y_WEBGL, true);
    (this.GL).bindTexture(this.GL.TEXTURE_2D, textureHandle);
    var arg_369_3 = this.GL.TEXTURE_2D;
    var arg_369_5 = this.GL.RGBA;
    var arg_369_6 = this.GL.RGBA;
    (this.GL).texImage2D(
      arg_369_3, 
      0, 
      arg_369_5, 
      arg_369_6, 
      this.GL.UNSIGNED_BYTE, 
      imageElement
    );
    var arg_4DD_3 = this.GL.TEXTURE_2D;
    var arg_4DD_4 = this.GL.TEXTURE_MAG_FILTER;
    (this.GL).texParameteri(arg_4DD_3, arg_4DD_4, this.GL.LINEAR);
    var arg_651_3 = this.GL.TEXTURE_2D;
    var arg_651_4 = this.GL.TEXTURE_MIN_FILTER;
    (this.GL).texParameteri(arg_651_3, arg_651_4, this.GL.LINEAR_MIPMAP_NEAREST);
    (this.GL).generateMipmap(this.GL.TEXTURE_2D);
    (this.GL).bindTexture(this.GL.TEXTURE_2D, null);
  };

  JSIL.MakeType({
      BaseType: $asm01.TypeRef("System.Object"), 
      Name: "RiftGL.View.ViewPort", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      ViewPort__ctor
    );

    $.Method({Static:false, Public:true }, "DrawLighting", 
      JSIL.MethodSignature.Action($.Object), 
      ViewPort_DrawLighting
    )
      .Parameter(0, "Document", function (_) {
          _.Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute"))
        });

    $.Method({Static:false, Public:true }, "InitMatrices", 
      JSIL.MethodSignature.Action($.Object), 
      ViewPort_InitMatrices
    )
      .Parameter(0, "canvas", function (_) {
          _.Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute"))
        });

    $.Method({Static:false, Public:true }, "UploadTexture", 
      new JSIL.MethodSignature(null, [$.Object, $.Object]), 
      ViewPort_UploadTexture
    );

    $.Field({Static:true , Public:true }, "GLVector3", $.Object)
      .Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute")); 
    $.Field({Static:true , Public:true }, "GLMatrix3", $.Object)
      .Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute")); 
    $.Field({Static:true , Public:true }, "GLMatrix4", $.Object)
      .Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute")); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Attributes", $asm02.TypeRef("RiftGL.Objects.AttributeCollection")); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Uniforms", $asm02.TypeRef("RiftGL.Objects.UniformCollection")); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Buffers", $asm02.TypeRef("RiftGL.Objects.BufferCollection")); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Matrices", $asm02.TypeRef("RiftGL.Objects.MatrixCollection")); 
    $.Field({Static:false, Public:true }, "GL", $.Object)
      .Attribute($asm05.TypeRef("System.Runtime.CompilerServices.DynamicAttribute")); 
    function ViewPort__cctor () {
      $thisType.Attributes = new ($T00())();
      $thisType.Uniforms = new ($T01())();
      $thisType.Buffers = new ($T02())();
      $thisType.Matrices = new ($T03())();
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      ViewPort__cctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

